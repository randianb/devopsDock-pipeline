Professional Summary:

So far, I have successfully updated the script to retrieve the latest image deployed on servers, allowing it to handle a list of input regions (e.g., ["paris", "north"]) and return multiple results. This update improves flexibility and ensures that we can manage multiple regions at once. Additionally, I integrated a process to retrieve servers based on a matching label, extract their image IDs, and then query the image name using the IDs. If the servers do not have the same image, a notification email is sent to the team to alert them.

Python Script with Best Practices:

import os
import sys
import subprocess
from common import logger, sgcloud
from contextlib import redirect_stdout

# Define constants for script directories and notification script
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
NOTIFY_SCRIPT = os.path.join(SCRIPT_DIR, "../scripts/notify_server_mismatch.sh")


def get_ocs_images(server_name, regions):
    """
    Retrieves image names for servers in the given regions.
    Arguments:
    server_name -- the name of the server to search for
    regions -- a list of regions to search in
    """
    sg_cloud_client = sgcloud.Client(
        os.environ["ACCOUNT_ID"], os.environ["CLIENT_ID"], os.environ["CLIENT_SECRET"]
    )
    servers_images = {}

    # Iterate over regions and retrieve the image details for each region
    for region in regions:
        image_map = sg_cloud_client.get_server_image_ids(server_name, region)

        if not isinstance(image_map, dict):
            logger.error(f"Unexpected data format for image_map: {type(image_map)} - {image_map}")
            continue

        for server, image_id in image_map.items():
            if not isinstance(image_id, str):
                logger.error(f"Invalid image ID format for {server}: {image_id}")
                continue

            image_name = sg_cloud_client.get_image_details(image_id, region)
            servers_images[server] = image_name

    return servers_images


def send_mismatch_notification(servers_images):
    """
    Sends a notification email if the servers do not have the same image.
    """
    unique_images = set(servers_images.values())
    if len(unique_images) > 1:
        mismatch_output = "\n".join(f"{server} = {image}" for server, image in servers_images.items())
        subprocess.run(["sh", NOTIFY_SCRIPT, mismatch_output], check=True)


def main():
    if len(sys.argv) < 3:
        print("Usage: python server_image_lookup.py <server_name> <regions>")
        sys.exit(1)

    server_name = sys.argv[1]
    regions = sys.argv[2].split(',')

    servers_images = get_ocs_images(server_name, regions)

    if not servers_images:
        print(f"ERROR: No valid image data found for {server_name} in {regions}")
        sys.exit(1)

    print("\nDeployed images on servers:")
    for server, image in servers_images.items():
        print(f"{server} = {image}")

    send_mismatch_notification(servers_images)


if __name__ == "__main__":
    main()

Summary (French Translation):

J'ai mis à jour le script permettant de récupérer l'image la plus récente déployée sur un serveur afin qu'il puisse gérer une liste de régions d'entrée (par exemple, ["paris", "north"]) et retourner plusieurs résultats. Cette mise à jour améliore la flexibilité et nous permet de gérer plusieurs régions simultanément. En outre, j'ai intégré un processus qui récupère les serveurs en fonction d'un label de correspondance, extrait leurs ID d'image, puis interroge le nom de l'image à partir des ID. Si les serveurs n'ont pas la même image, un email de notification est envoyé à l'équipe pour les alerter.

